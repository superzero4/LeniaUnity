#pragma kernel CSMain
#pragma kernel NoiseMain

RWStructuredBuffer<float> _buffer;
RWStructuredBuffer<float> _buffer2;
float _mainBuffer;

// #region Common
int ResX;
int ResY;
int ResZ;
int _Radius; // space resolution = kernel radius
float4 _Time;

bool firstFrame = false;
bool mouse = false;

int Index(uint3 id)
{
    //For now we only suppoer xy
    return id.z * ResX * ResY + id.y * ResX + id.x;
}

// #endregion
// #region Input
float ReadInput(uint3 txy)
{
    if (_mainBuffer > .5f)
        return _buffer[Index(txy)];
    else
        return _buffer2[Index(txy)];
    //With interpolation handled by the sampler, would support values that doesn't not represent preicely a pixel
    //return sampler_Input.SampleLevel(sampler_Input, float2(txy.x, txy.y) / float2(ResX, ResY), 0).r;
}

void WriteOutput(uint3 txy, float value)
{
    //The opposite
    if (_mainBuffer < .5f)
        _buffer[Index(txy)] = value;
    else
        _buffer2[Index(txy)] = value;
}

float bell(float x, float m, float s)
{
    //exp(-(x-m)^2/(2s^2))
    return exp(-((x - m) * (x - m)) / (s * s * 2.f)); // bell-shaped curve
}

float quad(float r)
{
    return pow(4 * r * (1 - r), 4);
}

float quadGrowth(float n, float m, float s)
{
    //  np.maximum(0, 1 - (n-m)**2 / (9 * s**2) )**4
    return pow(max(0, 1 - pow(n - m, 2) / (9 * s * s)), 4);
}

// Kernel 0
[numthreads(8,8,8)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float sum = 0.0f;
    float total = 0.0f;

    const float dt = 0.1f; // time step
    const float mu = 0.12f; // growth center
    const float sigma = 0.01f; // growth width
    const float rho = 0.5f; // kernel center
    const float omega = 0.15f; // kernel width
    for (int x = -_Radius; x <= _Radius; x++)
    {
        if (!(id.x >= x && id.x < ResX - x))
            continue;
        for (int y = -_Radius; y <= _Radius; y++)
        {
            if (!(id.y >= y && id.y < ResY - y))
                continue;
            for (int z = -_Radius; z <= _Radius; z++)
            {
                if (!(id.z >= z && id.z < ResZ - z))
                    continue;
                float r = sqrt(float(x * x + y * y + z * z)) / _Radius;
                if (r > 1.0f)
                    continue; //We want a circular quad kernel
                uint3 txyz = uint3(id.x + x, id.y + y, id.z + z);
                //float neighbourValue = ReadInput(txyz);
                float neighbourValue = 10;
                //float weight = bell(r, rho, omega);
                float weight = quad(r); //Used in original python lenia for 3D instead of bell for kenel
                sum += neighbourValue * weight;
                total += weight;
            }
        }
    }
    //GroupMemoryBarrierWithGroupSync();
    float avg = sum / total;
    float val = ReadInput(id);
    float growth = quadGrowth(avg, mu, sigma) * 2.0f - 1.0f;
    float color = clamp(val + dt * growth, 0.f, 1.f);
    uint3 center = id;
    //Debugging the quad kernel function "range"
    //color = quad(sqrt(float(center.x * center.x + center.y * center.y + center.z * center.z)) / _Radius);
    //avg =  .10f;
    //Debugging index of the buffer : float displayedValue = float(Index(id))/float(ResX*ResY*2);
    WriteOutput(id, color);
    //_Output[id.xy] = float4(uv.x, uv.y, 0, 1);

    /*
    if (_Time.y < 10.f || mouse)
    {
        c = 0.013f + noise(float2(id.x, id.y));
    }

    
    if (mouse)
    {
        float d = length((fragCoord.xy - iMouse.xy) / iResolution.xx);
        if (d <= R/iResolution.x) c = 0.02 + noise(fragCoord/R + mod(_Time.y,1.)*100.);
    }*/
}

// #endregion

// #region Noise
//Kernel 1

// Hash / noise functions
float2 hash(float2 p)
{
    p = float2(dot(p, float2(127.1f, 311.7f)), dot(p, float2(269.5f, 183.3f)));
    return -1.0f + 2.0f * frac(sin(p) * 43758.5453123f);
}

float noise(float2 p)
{
    const float k1 = 0.366025404f; // (sqrt(3)-1)/2;
    const float k2 = 0.211324865f; // (3-sqrt(3))/6;

    float2 i = floor(p + (p.x + p.y) * k1);
    float2 a = p - i + (i.x + i.y) * k2;
    float m = step(a.y, a.x);
    const float2 o = float2(m, 1.0f - m);
    const float2 b = a - o + k2;
    const float2 c = a - 1.0f + 2.0f * k2;
    const float3 h = max(0.5f - float3(dot(a, a), dot(b, b), dot(c, c)), 0.0f);
    const float3 n = h * h * h * h * float3(dot(a, hash(i + 0.0f)), dot(b, hash(i + o)), dot(c, hash(i + 1.0f)));
    return dot(n, 70.0f);
}

[numthreads(8,8,8)]
void NoiseMain(uint3 id : SV_DispatchThreadID)
{
    float x = float(id.x) / _Radius;
    float y = float(id.y) / _Radius;
    float z = (float(id.z) / ResZ) * 100;
    _buffer[Index(id)] = 0.073f + noise(float2(x + z, y + z));
}

// #endregion

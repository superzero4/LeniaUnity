#pragma kernel CSMain

Texture2D _Input;
SamplerState sampler_Input; // "sampler" + “_MainTex”
RWTexture2D<float4> _Output;

int ResX;
int ResY;
float4 _Time;

bool firstFrame = false;
bool mouse = false;

float bell(float x, float m, float s)
{
    return exp(-((x-m)*(x-m))/(s*s*2.0f));  // bell-shaped curve
}

float ReadInput(uint2 txy)
{
    return _Input[txy].r;
    //With interpolation handled by the sampler, would support values that doesn't not represent preicely a pixel
    //return sampler_Input.SampleLevel(sampler_Input, float2(txy.x, txy.y) / float2(ResX, ResY), 0).r;
}

// Kernel 0
[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 uv = float2(float(id.x) / float(ResX), float(id.y) / float(ResY));
    
    float sum = 0.0f;
    float total = 0.0f;

    const float R = 15.0f;      // space resolution = kernel radius
    const float T = 10.0f;      // time resolution = number of divisions per unit time
    const float dt = 1.0f/T;    // time step
    const float mu = 0.14f;     // growth center
    const float sigma = 0.014f; // growth width
    const float rho = 0.5f;     // kernel center
    const float omega = 0.15f;  // kernel width
    
    for (int x = -int(R); x <= int(R); x++)
    {
        for (int y = -int(R); y <= int(R); y++)
        {
            float r = sqrt(float(x*x + y*y)) / R;
            uint2 txy = uint2(id.x + x, id.y + y);
            float val2 = ReadInput(txy);
            float weight = bell(r, rho, omega);
            // Result[id.xy] = float4(txy.x, txy.y, 1.0f, 1.0f);
            sum += val2 * weight;
            total += weight;
        }
    }
    
    float avg = sum / total;    
    float val =  ReadInput(id);
    float growth = bell(avg, mu, sigma) * 2.0f - 1.0f;
    float c = val + dt * growth;
    float final = c;
    _Output[id.xy] = float4(final,final,final,1);
    //_Output[id.xy] = float4(uv.x, uv.y, 0, 1);
    
    /*
    if (_Time.y < 10.f || mouse)
    {
        c = 0.013f + noise(float2(id.x, id.y));
    }

    
    if (mouse)
    {
        float d = length((fragCoord.xy - iMouse.xy) / iResolution.xx);
        if (d <= R/iResolution.x) c = 0.02 + noise(fragCoord/R + mod(_Time.y,1.)*100.);
    }*/
}